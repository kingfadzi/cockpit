/**
 * Mock Risk Generators for ARB Dashboard
 * Based on profile-fields.registry.yaml
 */

import { Risk } from '../api/types';
import { currentMockUser, getMockUserById } from './mockUsers';

// Policy field keys from registry
const SECURITY_FIELDS = [
  'waf_protection',
  'encryption_at_rest',
  'encryption_in_transit',
  'security_testing',
  'mfa_enforcement',
  'dependency_management',
  'network_segmentation',
  'siem_integration',
  'secrets_management',
  'key_rotation_max'
];

const DATA_FIELDS = [
  'confidentiality_level',
  'data_residency_control',
  'de_identification',
  'access_review',
  'data_retention_policy',
  'audit_logging',
  'data_validation',
  'reconciliation_frequency',
  'log_retention',
  'data_deletion_evidence',
  'tpsp_attestation'
];

const OPERATIONS_FIELDS = [
  'rto_hours',
  'rpo_minutes',
  'dr_test_frequency',
  'ir_plan',
  'ir_exercise',
  'backup_policy',
  'monitoring_slos',
  'ha_topology',
  'oncall_coverage',
  'failover_automation',
  'runbook_maturity',
  'chaos_testing'
];

const EA_FIELDS = [
  'product_vision',
  'product_roadmap',
  'architecture_vision',
  'service_vision',
  'security_vision',
  'test_vision'
];

let riskIdCounter = 1;

function generateRiskId(): string {
  return `risk-${String(riskIdCounter++).padStart(4, '0')}`;
}

function getRandomItem<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

function getRandomDate(daysAgo: number): string {
  const date = new Date();
  date.setDate(date.getDate() - daysAgo);
  return date.toISOString();
}

/**
 * Generate auto-generated risk from policy
 */
export function generateAutoGeneratedRisk(
  appName: string,
  arbDomain: 'security' | 'data' | 'operations' | 'enterprise_architecture',
  riskType: 'MISSING_EVIDENCE' | 'STALE_EVIDENCE' | 'POLICY_VIOLATION',
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
  assignedToId?: string
): Risk {
  const fieldMap = {
    security: SECURITY_FIELDS,
    data: DATA_FIELDS,
    operations: OPERATIONS_FIELDS,
    enterprise_architecture: EA_FIELDS
  };

  const fieldKey = getRandomItem(fieldMap[arbDomain]);
  const createdDaysAgo = Math.floor(Math.random() * 30) + 1;
  const ttlDays = priority === 'CRITICAL' || priority === 'HIGH' ? 90 : priority === 'MEDIUM' ? 180 : 365;

  const titles = {
    MISSING_EVIDENCE: `Missing Evidence: ${fieldKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`,
    STALE_EVIDENCE: `Stale Evidence: ${fieldKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (${ttlDays + Math.floor(Math.random() * 30)} days old)`,
    POLICY_VIOLATION: `Policy Violation: ${fieldKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`
  };

  const descriptions = {
    MISSING_EVIDENCE: `Application "${appName}" has not provided required evidence for ${fieldKey}. This control is required based on the application's rating.`,
    STALE_EVIDENCE: `Evidence for ${fieldKey} is stale and requires refresh. Last evidence provided ${ttlDays + Math.floor(Math.random() * 30)} days ago, exceeding the ${ttlDays}-day TTL requirement.`,
    POLICY_VIOLATION: `Application "${appName}" violates policy requirements for ${fieldKey}. Immediate remediation required.`
  };

  const assignedUser = assignedToId ? getMockUserById(assignedToId) : null;
  const statusOptions = priority === 'CRITICAL' ? ['PENDING_REVIEW', 'OPEN', 'IN_PROGRESS'] : ['PENDING_REVIEW', 'OPEN', 'IN_PROGRESS', 'ACCEPTED'];
  const status = getRandomItem(statusOptions) as Risk['status'];

  const daysOverdue = riskType === 'STALE_EVIDENCE' ? Math.floor(Math.random() * 30) + 1 : undefined;

  return {
    id: generateRiskId(),
    title: titles[riskType],
    description: descriptions[riskType],
    priority,
    status,
    arbDomain,
    isAutoGenerated: true,
    fieldKey,
    riskType,
    ttlDays,
    daysOverdue,
    assignedTo: assignedUser?.id || null,
    assignedToName: assignedUser?.name || null,
    createdDate: getRandomDate(createdDaysAgo),
    updatedDate: getRandomDate(Math.floor(createdDaysAgo / 2)),
    dueDate: priority === 'CRITICAL' || priority === 'HIGH' ?
      getRandomDate(-Math.floor(Math.random() * 14 + 7)) : null,
    tags: [arbDomain, riskType.toLowerCase(), fieldKey]
  };
}

/**
 * Generate manually created risk
 */
export function generateManualRisk(
  appName: string,
  arbDomain: 'security' | 'data' | 'operations' | 'enterprise_architecture',
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
): Risk {
  const manualRiskTitles = {
    security: [
      'Missing Rate Limiting on Public API',
      'Insufficient Session Timeout Configuration',
      'Unencrypted Communication Between Microservices',
      'Weak Password Policy Implementation'
    ],
    data: [
      'Insufficient Data Lineage Documentation',
      'Unclear Data Ownership',
      'Missing Data Quality Metrics',
      'Inconsistent Data Classification Labels'
    ],
    operations: [
      'No Load Testing for Peak Traffic',
      'Missing Capacity Planning Documentation',
      'Inadequate Runbook Detail',
      'No Chaos Engineering Practice'
    ],
    enterprise_architecture: [
      'Architecture Drift from Enterprise Standards',
      'Missing API Versioning Strategy',
      'Inconsistent Logging Format Across Services',
      'No Deprecation Plan for Legacy Components'
    ]
  };

  const title = getRandomItem(manualRiskTitles[arbDomain]);
  const createdDaysAgo = Math.floor(Math.random() * 20) + 1;
  const creator = currentMockUser;

  return {
    id: generateRiskId(),
    title,
    description: `During architecture review of "${appName}", identified: ${title}. This requires attention from the application team.`,
    priority,
    status: getRandomItem(['OPEN', 'IN_PROGRESS']) as Risk['status'],
    arbDomain,
    isAutoGenerated: false,
    createdBy: creator.id,
    createdByName: creator.name,
    assignedTo: null,
    assignedToName: null,
    createdDate: getRandomDate(createdDaysAgo),
    updatedDate: getRandomDate(Math.floor(createdDaysAgo / 2)),
    dueDate: getRandomDate(-Math.floor(Math.random() * 21 + 7)),
    category: 'Manual Review Finding',
    tags: [arbDomain, 'manual-finding', 'review'],
    comments: Math.random() > 0.5 ? [{
      id: `comment-${generateRiskId()}`,
      userId: creator.id,
      userName: creator.name,
      text: 'Discussed with application team. They are working on remediation.',
      createdDate: getRandomDate(Math.floor(createdDaysAgo / 3))
    }] : undefined
  };
}

/**
 * Generate risk set for an application
 */
export function generateRisksForApp(
  appName: string,
  riskCount: number,
  primaryDomain: 'security' | 'data' | 'operations' | 'enterprise_architecture',
  assignSomeToCurrentUser: boolean = false
): Risk[] {
  const risks: Risk[] = [];
  const manualRiskCount = Math.floor(riskCount * 0.2); // 20% manual
  const autoRiskCount = riskCount - manualRiskCount;

  // Generate auto-generated risks (80%)
  for (let i = 0; i < autoRiskCount; i++) {
    const priority = i < riskCount * 0.3 ? 'CRITICAL' :
                    i < riskCount * 0.6 ? 'HIGH' :
                    i < riskCount * 0.85 ? 'MEDIUM' : 'LOW';

    const riskType = getRandomItem<Risk['riskType']>([
      'MISSING_EVIDENCE',
      'STALE_EVIDENCE',
      'POLICY_VIOLATION'
    ])!;

    const domain = Math.random() > 0.7 ?
      getRandomItem<Risk['arbDomain']>(['security', 'data', 'operations', 'enterprise_architecture'])! :
      primaryDomain;

    const assignToUser = assignSomeToCurrentUser && Math.random() > 0.6 ?
      currentMockUser.id :
      undefined;

    risks.push(generateAutoGeneratedRisk(appName, domain, riskType, priority as Risk['priority'], assignToUser));
  }

  // Generate manual risks (20%)
  for (let i = 0; i < manualRiskCount; i++) {
    const priority = i < manualRiskCount * 0.3 ? 'HIGH' :
                    i < manualRiskCount * 0.7 ? 'MEDIUM' : 'LOW';

    risks.push(generateManualRisk(appName, primaryDomain, priority as Risk['priority']));
  }

  return risks;
}
